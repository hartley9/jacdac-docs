{"version":3,"file":"1136-6ae34f8d1a4ca315bec5.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAmL,CAAC;;AAEpL,yBAAyB,8BAAiB;AAC1C;AACA;AACA,gBAAgB,6BAAgB;AAChC,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA,2DAA2D;AAC3D,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,WAAW;AACvC;AACA,cAAc;;AAEd,YAAY;AACZ;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CAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,cAAc,0CAAwB;;AAEtC,cAAc,0CAAQ;AACtB;AACA;AACA,MAAM;AACN;AACA,GAAG;AACH,WAAW,0CAAQ;AACnB;AACA;AACA,MAAM;AACN;AACA,GAAG;AACH,qBAAqB,YAAY;AACjC,gIAAgI,aAAa;AAC7I,2BAA2B,8BAAuB;AAClD,+BAA+B,8BAAuB;AACtD;AACA,4BAA4B,gCAAyB;AACrD,wBAAwB,iBAAU;AAClC,4BAA4B,8BAAuB;AACnD;;AAEA,mIAAmI,wCAAwC;;AAE3K,qCAAqC,2BAAoB,CAAC,oBAAoB;AAC9E,mCAAmC,2BAAoB,CAAC,kBAAkB;AAC1E;AACA;AACA,GAAG;AACH;AACA,EAAE,0CAAQ;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,sBAAsB,mBAAmB,UAAU,8BAAQ,GAAG;AAC9D;AACA,GAAG,gBAAgB,mBAAmB;AACtC;AACA;AACA;AACA,GAAG,eAAe,mBAAmB;AACrC;AACA;AACA;AACA,GAAG,iBAAiB,mBAAmB;AACvC;AACA;AACA,GAAG;AACH,CAAC;;;ACtFgJ;AACjJ,IAAI,cAAS;AAC6C;AAC3B;AACA;AACe;AACC;AACM;AACrD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,cAAc,0CAAwB,OAAO,cAAS;;AAEtD;AACA,eAAe,0CAAQ,yBAAyB;;AAEhD,wBAAwB,0CAAQ;AAChC,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA,GAAG,SAAS,cAAc;AAC1B;AACA;AACA;AACA,GAAG;AACH,EAAE,qBAAqB;AACvB;AACA;AACA,mBAAmB,iBAAU;AAC7B,qBAAqB,oBAAa;AAClC,qBAAqB,mBAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,EAAE,qBAAqB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN,GAAG;AACH,sBAAsB,mBAAmB,8BAA8B,mBAAmB;AAC1F;AACA,GAAG,eAAe,mBAAmB;AACrC;AACA,GAAG,4CAA4C,mBAAmB,CAAC,cAAc,EAAE,8BAAQ;AAC3F;AACA;AACA;AACA;AACA,GAAG,+CAA+C,mBAAmB,CAAC,WAAW;AACjF;AACA,GAAG,gBAAgB,mBAAmB;AACtC;AACA,GAAG,gBAAgB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG,gBAAgB,mBAAmB;AACtC;AACA;AACA,GAAG;AACH;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AAEe,4BAA4B;AACvC;AACA,MAAM;AAAA;AAAA;AAAA;AAA+BA,IAAAA;AAA/B,MAAN;AACA,MAAMC,GAAG,GAAGC,gBAAZ;AACA,MAAMC,SAAS,GAAGD,gBAAlB;AACA,MAAME,kBAAkB,GACpB,mCAAmC,CAAC,CAACC,QAAQ,CADjD;;AAEA,MAAMC,gBAAgB,GAAG;AAAA;;AAAA,iCAAMH,SAAS,CAAf,8DAAMA,kBAAAA,CAAN,iBAAMA,EAAN;AAAzB;;AACA,sBACI;AACI,OAAG,EADP;AAEI,SAAK,EACDI,KAAK,WAECC,UAAU,GACV;AACIC,MAAAA,QAAQ,EADZ;AAEIC,MAAAA,KAAK,EAFT;AAGIC,MAAAA,MAAM,EAAE;AAHZ,KADU,GAMV;AACIF,MAAAA,QAAQ,EADZ;AAEIC,MAAAA,KAAK,EAFT;AAGIC,MAAAA,MAAM,EAAE;AAHZ;AAXd,kBAkBI;AAAQ,WAAO,EAAf;AAAgB,OAAG,EAAE,IAArB,CAAqB,CAArB;AAA6B,UAAM,EAAE;AAAEC,MAAAA,GAAG,EAAE;AAAP;AAArC,kBACI;AAAU,YAAQ,EAAE;AAApB,kBACI;AACI,YAAQ,EADZ;AAEI,aAAS,EAFb;AAGI,iBAAa,EAHjB;AAII,WAAO,EAJX;AAKI,gBAAY;AALhB,KAFR,QAEQ,CADJ,CADJ,eAYI;AAAe,OAAG,EAAlB;AAAyB,cAAU,EAAE,CAAC,CAACZ;AAAvC,IAZJ,CAlBJ,EAgCKI,kBAAkB,iBACf;AACI,SAAK,EAAE;AACHK,MAAAA,QAAQ,EADL;AAEHI,MAAAA,KAAK,EAFF;AAGHC,MAAAA,MAAM,EAAE;AAHL,KADX;AAMI,QAAI,EANR;AAOI,WAAO,EAPX;AAQI,SAAK,EAAC;AARV,kBAUI,+CA5ChB,IA4CgB,CAVJ,CAjCR,CADJ;AAiDH","sources":["webpack://jacdac-docs/./node_modules/three-stdlib/loaders/RGBELoader.js","webpack://jacdac-docs/./node_modules/@react-three/drei/helpers/environment-assets.js","webpack://jacdac-docs/./node_modules/@react-three/drei/core/Environment.js","webpack://jacdac-docs/./node_modules/three-stdlib/shaders/HorizontalBlurShader.js","webpack://jacdac-docs/./node_modules/three-stdlib/shaders/VerticalBlurShader.js","webpack://jacdac-docs/./node_modules/@react-three/drei/core/ContactShadows.js","webpack://jacdac-docs/./node_modules/@react-three/drei/core/Stage.js","webpack://jacdac-docs/./src/components/home/models/ModelViewer.js"],"sourcesContent":["import { DataTextureLoader, UnsignedByteType, HalfFloatType, FloatType, DataUtils, RGBFormat, RGBEFormat, LinearEncoding, LinearFilter, RGBEEncoding, NearestFilter } from 'three'; // http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = UnsignedByteType;\n  } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\n  parse(buffer) {\n    var\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n        rgbe_write_error = 2,\n        rgbe_format_error = 3,\n        rgbe_memory_error = 4,\n        rgbe_error = function rgbe_error(rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n        RGBE_VALID_FORMAT = 2,\n        RGBE_VALID_DIMENSIONS = 4,\n        NEWLINE = '\\n',\n        fgets = function fgets(buffer, lineLimit, consume) {\n      var chunkSize = 128;\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      var p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        byteCode = m.charCodeAt(i);\n        if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {\n      // regexes to parse header info fields\n      var magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n      header = {\n        valid: 0\n        /* indicate which fields are valid */\n        ,\n        string: ''\n        /* the actual header string */\n        ,\n        comments: ''\n        /* comments found in header */\n        ,\n        programtype: 'RGBE'\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        ,\n        format: ''\n        /* RGBE format, default 32-bit_rle_rgbe */\n        ,\n        gamma: 1.0\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        ,\n        exposure: 1.0\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        ,\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n      var line, match;\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, 'no header found');\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, 'bad initial token');\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + '\\n';\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + '\\n';\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + '\\n';\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1], 10);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, 'missing format specifier');\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n      }\n\n      return header;\n    },\n        RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {\n      var scanline_width = w;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n      }\n\n      var data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n      }\n\n      var offset = 0,\n          pos = 0;\n      var ptr_end = 4 * scanline_width;\n      var rgbeStart = new Uint8Array(4);\n      var scanline_buffer = new Uint8Array(ptr_end);\n      var num_scanlines = h; // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        var ptr = 0,\n            count = void 0;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          var isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, 'bad scanline data');\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            var byteValue = buffer[pos++];\n\n            for (var i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        var l = scanline_width; //scanline_buffer.byteLength;\n\n        for (var _i = 0; _i < l; _i++) {\n          var off = 0;\n          data_rgba[offset] = scanline_buffer[_i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[_i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[_i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[_i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n    };\n\n    var RGBEByteToRGBHalf = function RGBEByteToRGBHalf(sourceArray, sourceOffset, destArray, destOffset) {\n      var e = sourceArray[sourceOffset + 3];\n      var scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);\n    };\n\n    var byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    var rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      var w = rgbe_header_info.width,\n          h = rgbe_header_info.height,\n          image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        var data, format, type;\n        var numElements;\n\n        switch (this.type) {\n          case UnsignedByteType:\n            data = image_rgba_data;\n            format = RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n            type = UnsignedByteType;\n            break;\n\n          case FloatType:\n            numElements = image_rgba_data.length / 4 * 3;\n            var floatArray = new Float32Array(numElements);\n\n            for (var j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n            }\n\n            data = floatArray;\n            format = RGBFormat;\n            type = FloatType;\n            break;\n\n          case HalfFloatType:\n            numElements = image_rgba_data.length / 4 * 3;\n            var halfArray = new Uint16Array(numElements);\n\n            for (var _j = 0; _j < numElements; _j++) {\n              RGBEByteToRGBHalf(image_rgba_data, _j * 4, halfArray, _j * 3);\n            }\n\n            data = halfArray;\n            format = RGBFormat;\n            type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case UnsignedByteType:\n          texture.encoding = RGBEEncoding;\n          texture.minFilter = NearestFilter;\n          texture.magFilter = NearestFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n\n}\n\nexport { RGBELoader };","var presetsObj = {\n  sunset: 'venice_sunset_1k.hdr',\n  dawn: 'kiara_1_dawn_1k.hdr',\n  night: 'dikhololo_night_1k.hdr',\n  warehouse: 'empty_warehouse_01_1k.hdr',\n  forest: 'forest_slope_1k.hdr',\n  apartment: 'lebombo_1k.hdr',\n  studio: 'studio_small_03_1k.hdr',\n  city: 'potsdamer_platz_1k.hdr',\n  park: 'rooitou_park_1k.hdr',\n  lobby: 'st_fagans_interior_1k.hdr'\n};\nexport { presetsObj };","import * as React from 'react';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport { PMREMGenerator, CubeTextureLoader } from 'three';\nimport { RGBELoader } from 'three-stdlib';\nimport { useAsset } from 'use-asset';\nimport { presetsObj } from '../helpers/environment-assets.js';\n\nfunction getTexture(texture, gen, isCubeMap) {\n  if (isCubeMap) {\n    gen.compileEquirectangularShader();\n    return gen.fromCubemap(texture).texture;\n  }\n\n  return gen.fromEquirectangular(texture).texture;\n}\n\nvar CUBEMAP_ROOT = 'https://rawcdn.githack.com/pmndrs/drei-assets/aa3600359ba664d546d05821bcbca42013587df2';\n\nfunction Environment(_ref) {\n  var {\n    background = false,\n    files = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'],\n    path = '',\n    preset = undefined,\n    scene,\n    extensions\n  } = _ref;\n\n  if (preset) {\n    if (!(preset in presetsObj)) {\n      throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));\n    }\n\n    files = presetsObj[preset];\n    path = CUBEMAP_ROOT + '/hdri/';\n  }\n\n  var defaultScene = useThree(_ref2 => {\n    var {\n      scene\n    } = _ref2;\n    return scene;\n  });\n  var gl = useThree(_ref3 => {\n    var {\n      gl\n    } = _ref3;\n    return gl;\n  });\n  var isCubeMap = Array.isArray(files);\n  var loader = isCubeMap ? CubeTextureLoader : RGBELoader; // @ts-expect-error\n\n  var loaderResult = useLoader(loader, isCubeMap ? [files] : files, loader => {\n    loader.setPath(path);\n    if (extensions) extensions(loader);\n  });\n  var map = isCubeMap ? loaderResult[0] : loaderResult; // PMREMGenerator takes its sweet time to generate the env-map,\n  // Let's make this part of suspense, or else it just yields a frame-skip\n\n  var texture = useAsset(() => new Promise(res => {\n    var gen = new PMREMGenerator(gl);\n    var texture = getTexture(map, gen, isCubeMap);\n    gen.dispose();\n    res(texture);\n  }), map);\n  React.useLayoutEffect(() => {\n    var oldbg = scene ? scene.background : defaultScene.background;\n    var oldenv = scene ? scene.environment : defaultScene.environment;\n\n    if (scene) {\n      scene.environment = texture;\n      if (background) scene.background = texture;\n    } else {\n      defaultScene.environment = texture;\n      if (background) defaultScene.background = texture;\n    }\n\n    return () => {\n      if (scene) {\n        scene.environment = oldenv;\n        scene.background = oldbg;\n      } else {\n        defaultScene.environment = oldenv;\n        defaultScene.background = oldbg;\n      } // Environment textures are volatile, better dispose and uncache them\n\n\n      useAsset.clear(map);\n      texture.dispose();\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [texture, background, scene]);\n  return null;\n}\n\nexport { Environment };","/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\nvar HorizontalBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    h: {\n      value: 1.0 / 512.0\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n      varying vec2 vUv;\\n\\n      void main() {\\n\\n        vUv = uv;\\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n      }\\n  \",\n  fragmentShader:\n  /* glsl */\n  \"\\n    uniform sampler2D tDiffuse;\\n    uniform float h;\\n\\n    varying vec2 vUv;\\n\\n    void main() {\\n\\n    \\tvec4 sum = vec4( 0.0 );\\n\\n    \\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\\n    \\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\\n    \\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\\n    \\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\\n    \\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\\n    \\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\\n    \\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\\n    \\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\\n    \\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\\n\\n    \\tgl_FragColor = sum;\\n\\n    }\\n  \"\n};\nexport { HorizontalBlurShader };","/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\nvar VerticalBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    v: {\n      value: 1.0 / 512.0\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n    varying vec2 vUv;\\n\\n    void main() {\\n\\n      vUv = uv;\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n    }\\n  \",\n  fragmentShader:\n  /* glsl */\n  \"\\n  \\n  uniform sampler2D tDiffuse;\\n  uniform float v;\\n\\n  varying vec2 vUv;\\n\\n  void main() {\\n\\n    vec4 sum = vec4( 0.0 );\\n\\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\\n\\n    gl_FragColor = sum;\\n\\n  }\\n  \"\n};\nexport { VerticalBlurShader };","import _objectWithoutProperties from \"/home/runner/work/jacdac-docs/jacdac-docs/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"frames\", \"opacity\", \"width\", \"height\", \"blur\", \"far\", \"resolution\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { HorizontalBlurShader, VerticalBlurShader } from 'three-stdlib';\nvar ContactShadows = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  var {\n    frames = Infinity,\n    opacity = 1,\n    width = 1,\n    height = 1,\n    blur = 1,\n    far = 10,\n    resolution = 256\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  var scene = useThree(_ref2 => {\n    var {\n      scene\n    } = _ref2;\n    return scene;\n  });\n  var gl = useThree(_ref3 => {\n    var {\n      gl\n    } = _ref3;\n    return gl;\n  });\n  var shadowCamera = React.useRef();\n  var [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = React.useMemo(() => {\n    var renderTarget = new THREE.WebGLRenderTarget(resolution, resolution);\n    var renderTargetBlur = new THREE.WebGLRenderTarget(resolution, resolution);\n    renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n    var planeGeometry = new THREE.PlaneBufferGeometry(width, height).rotateX(Math.PI / 2);\n    var blurPlane = new THREE.Mesh(planeGeometry);\n    var depthMaterial = new THREE.MeshDepthMaterial();\n    depthMaterial.depthTest = depthMaterial.depthWrite = false;\n\n    depthMaterial.onBeforeCompile = shader => shader.fragmentShader = shader.fragmentShader.replace('1.0 - fragCoordZ ), opacity );', '0.0 ), ( 1.0 - fragCoordZ ) * 1.0 );');\n\n    var horizontalBlurMaterial = new THREE.ShaderMaterial(HorizontalBlurShader);\n    var verticalBlurMaterial = new THREE.ShaderMaterial(VerticalBlurShader);\n    verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n    return [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur];\n  }, [resolution, width, height]);\n  var count = 0;\n  useFrame(() => {\n    if (shadowCamera.current && (frames === Infinity || count < frames)) {\n      var initialBackground = scene.background;\n      scene.background = null;\n      scene.overrideMaterial = depthMaterial;\n      gl.setRenderTarget(renderTarget);\n      gl.render(scene, shadowCamera.current);\n      scene.overrideMaterial = null;\n      blurPlane.material = horizontalBlurMaterial;\n      blurPlane.material.uniforms.tDiffuse.value = renderTarget.texture;\n      horizontalBlurMaterial.uniforms.h.value = blur / 256;\n      gl.setRenderTarget(renderTargetBlur);\n      gl.render(blurPlane, shadowCamera.current);\n      blurPlane.material = verticalBlurMaterial;\n      blurPlane.material.uniforms.tDiffuse.value = renderTargetBlur.texture;\n      verticalBlurMaterial.uniforms.v.value = blur / 256;\n      gl.setRenderTarget(renderTarget);\n      gl.render(blurPlane, shadowCamera.current);\n      gl.setRenderTarget(null);\n      scene.background = initialBackground;\n      count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"mesh\", {\n    geometry: planeGeometry,\n    scale: [1, -1, 1],\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    map: renderTarget.texture,\n    transparent: true,\n    opacity: opacity\n  })), /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: shadowCamera,\n    args: [-width / 2, width / 2, height / 2, -height / 2, 0, far]\n  }));\n});\nexport { ContactShadows };","import _objectWithoutProperties from \"/home/runner/work/jacdac-docs/jacdac-docs/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"children\", \"controls\", \"shadows\", \"adjustCamera\", \"environment\", \"intensity\", \"preset\", \"shadowBias\", \"contactShadow\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { Environment } from './Environment.js';\nimport { ContactShadows } from './ContactShadows.js';\nvar presets = {\n  rembrandt: {\n    main: [1, 2, 1],\n    fill: [-2, -0.5, -2]\n  },\n  portrait: {\n    main: [-1, 2, 0.5],\n    fill: [-1, 0.5, -1.5]\n  },\n  upfront: {\n    main: [0, 2, 1],\n    fill: [-1, 0.5, -1.5]\n  },\n  soft: {\n    main: [-2, 4, 4],\n    fill: [-1, 0.5, -1.5]\n  }\n};\n\nfunction Stage(_ref) {\n  var {\n    children,\n    controls,\n    shadows = true,\n    adjustCamera = true,\n    environment = 'city',\n    intensity = 1,\n    preset = 'rembrandt',\n    shadowBias = 0,\n    contactShadow = {\n      blur: 2,\n      opacity: 0.5,\n      position: [0, 0, 0]\n    }\n  } = _ref,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  var config = presets[preset];\n  var camera = useThree(state => state.camera); // @ts-expect-error new in @react-three/fiber@7.0.5\n\n  var defaultControls = useThree(state => state.controls);\n  var outer = React.useRef(null);\n  var inner = React.useRef(null);\n  var [{\n    radius,\n    width,\n    height\n  }, set] = React.useState({\n    radius: 0,\n    width: 0,\n    height: 0\n  });\n  React.useLayoutEffect(() => {\n    outer.current.position.set(0, 0, 0);\n    outer.current.updateWorldMatrix(true, true);\n    var box3 = new THREE.Box3().setFromObject(inner.current);\n    var center = new THREE.Vector3();\n    var sphere = new THREE.Sphere();\n    var height = box3.max.y - box3.min.y;\n    var width = box3.max.x - box3.min.x;\n    box3.getCenter(center);\n    box3.getBoundingSphere(sphere);\n    set({\n      radius: sphere.radius,\n      width,\n      height\n    });\n    outer.current.position.set(-center.x, -center.y + height / 2, -center.z);\n  }, [children]);\n  React.useLayoutEffect(() => {\n    if (adjustCamera) {\n      var y = radius / (height > width ? 1.5 : 2.5);\n      camera.position.set(0, radius * 0.5, radius * 2.5);\n      camera.near = 0.1;\n      camera.far = Math.max(5000, radius * 4);\n      camera.lookAt(0, y, 0);\n      var ctrl = defaultControls || (controls == null ? void 0 : controls.current);\n\n      if (ctrl) {\n        ctrl.target.set(0, y, 0);\n        ctrl.update();\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [defaultControls, radius, height, width, adjustCamera]);\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    ref: outer\n  }, /*#__PURE__*/React.createElement(\"group\", {\n    ref: inner\n  }, children)), contactShadow && /*#__PURE__*/React.createElement(ContactShadows, _extends({\n    \"rotation-x\": Math.PI / 2,\n    width: radius * 2,\n    height: radius * 2,\n    far: radius / 2\n  }, contactShadow)), environment && /*#__PURE__*/React.createElement(Environment, {\n    preset: environment\n  }), /*#__PURE__*/React.createElement(\"ambientLight\", {\n    intensity: intensity / 3\n  }), /*#__PURE__*/React.createElement(\"spotLight\", {\n    penumbra: 1,\n    position: [config.main[0] * radius, config.main[1] * radius, config.main[2] * radius],\n    intensity: intensity * 2,\n    castShadow: shadows,\n    \"shadow-bias\": shadowBias\n  }), /*#__PURE__*/React.createElement(\"pointLight\", {\n    position: [config.fill[0] * radius, config.fill[1] * radius, config.fill[2] * radius],\n    intensity: intensity\n  }));\n}\n\nexport { Stage };","import React, { Suspense, useRef } from \"react\"\nimport { Canvas } from \"@react-three/fiber\"\nimport { OrbitControls, Stage } from \"@react-three/drei\"\nimport FullscreenIcon from \"@mui/icons-material/Fullscreen\"\nimport IconButtonWithTooltip from \"../../ui/IconButtonWithTooltip\"\n\nexport default function ModelViewer(props) {\n    // eslint-disable-next-line react/prop-types\n    const { children, responsive, style, autoRotate } = props\n    const ref = useRef()\n    const canvasRef = useRef()\n    const supportsFullScreen =\n        typeof document !== \"undefined\" && !!document.fullscreenEnabled\n    const handleFullScreen = () => canvasRef.current?.requestFullscreen()\n    return (\n        <div\n            ref={canvasRef}\n            style={\n                style\n                    ? style\n                    : responsive\n                    ? {\n                          position: \"relative\",\n                          width: \"35vw\",\n                          height: \"35vw\",\n                      }\n                    : {\n                          position: \"relative\",\n                          width: \"clamp(50vw, 640px, 96vw)\",\n                          height: \"clamp(480px, 60vh, 96vh)\",\n                      }\n            }\n        >\n            <Canvas shadows dpr={[1, 2]} camera={{ fov: 50 }}>\n                <Suspense fallback={null}>\n                    <Stage\n                        controls={ref}\n                        intensity={0.5}\n                        contactShadow\n                        shadows\n                        adjustCamera\n                    >\n                        {children}\n                    </Stage>\n                </Suspense>\n                <OrbitControls ref={ref} autoRotate={!!autoRotate} />\n            </Canvas>\n            {supportsFullScreen && (\n                <IconButtonWithTooltip\n                    style={{\n                        position: \"absolute\",\n                        right: \"0.5rem\",\n                        bottom: \"0.5rem\",\n                    }}\n                    size=\"small\"\n                    onClick={handleFullScreen}\n                    title=\"full screen\"\n                >\n                    <FullscreenIcon />\n                </IconButtonWithTooltip>\n            )}\n        </div>\n    )\n}\n"],"names":["autoRotate","ref","useRef","canvasRef","supportsFullScreen","document","handleFullScreen","style","responsive","position","width","height","fov","right","bottom"],"sourceRoot":""}